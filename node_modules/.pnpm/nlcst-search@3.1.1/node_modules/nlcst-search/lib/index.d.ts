/**
 * Search for phrases in a tree.
 *
 * @param {Node} tree
 *   Tree to search.
 * @param {PhrasesList | PhrasesMap} phrases
 *   Phrases to search for.
 * @param {Handler} handler
 *   Handle a match
 * @param {boolean | Options} [options=false]
 *   Configuration (or `allowApostrophes`).
 * @returns {void}
 *   Nothing.
 */
export function search(
  tree: Node,
  phrases: PhrasesList | PhrasesMap,
  handler: Handler,
  options?: boolean | Options | undefined
): void
export type UnistParent = import('unist').Parent
export type Root = import('nlcst').Root
export type Content = import('nlcst').Content
export type NormalizeOptions = import('nlcst-normalize').Options
export type Node = Root | Content
export type Parent = Extract<Node, UnistParent>
/**
 * Configuration (optional).
 */
export type Options = NormalizeOptions & {
  allowLiterals?: boolean
}
/**
 * List of phrases.
 *
 * Each phrase is a space-separated list of words, where each word will be
 * normalized to remove casing, apostrophes, and dashes.
 * Spaces in a pattern mean one or more whitespace nodes in the tree.
 * Instead of a word with letters, itâ€™s also possible to use a wildcard
 * symbol (`*`, an asterisk) which will match any word in a pattern
 * (`alpha * charlie`).
 */
export type PhrasesList = Array<string>
/**
 * Map where the keys are phrases.
 */
export type PhrasesMap = Record<string, unknown>
/**
 * Handle a match.
 */
export type Handler = (
  nodes: Array<Content>,
  index: number,
  parent: Parent,
  phrase: string
) => void
